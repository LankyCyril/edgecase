#!/usr/bin/env python3

"""
edgeCase
========

Usage: {0} [-h | --help]
       {0} <command> [<args>...]

Commmands (<command>):
    tailpuller     select overhanging reads
    tailchopper    get overhanging heads/tails of reads
    repeatfinder   discover enriched repeats in candidate sequences
    kmerscanner    perform scan of known kmers/motifs
    levenshtein    cluster reads by edit distance
    densityplot    visualize densities of candidate motifs
"""

from docopt import docopt
from sys import stdout, stderr
from inspect import getfullargspec
from re import sub, search
import edgecaselib


def postprocess_docopt(submodule, docopt_dict, __command_doc__):
    """Interpret and validate aruments returned by docopt"""
    kwargs = {
        sub(r'^[<>-]+|[<>-]+$', "", k).replace("-", "_"): v
        for k, v in docopt_dict.items() if search(r'[^<>-]', k)
    }
    for converter in getattr(submodule, "__docopt_converters__", []):
        converter_arg_names = getfullargspec(converter).args
        if len(converter_arg_names) != 1:
            error_mask = "Incorrect argument converter for: {}"
            exit(error_mask.format(", ".join(converter_arg_names)))
        elif converter_arg_names[0] not in kwargs:
            error_mask = "Unknown converter argument: {}"
            exit(error_mask.format(converter_arg_names[0]))
        else:
            key = converter_arg_names[0]
            try:
                kwargs[key] = converter(kwargs[key])
            except Exception:
                exit(__command_doc__)
    for test, error in getattr(submodule, "__docopt_tests__", {}).items():
        test_arg_names = getfullargspec(test).args
        test_arguments = [kwargs[k] for k in test_arg_names]
        if not test(*test_arguments):
            if error:
                exit("Error: " + error.format(*test_arguments))
            else:
                exit("Could not validate: {}".format(", ".join(test_arg_names)))
    return kwargs


def main(module):
    """Dispatch command line arguments to subroutines (commands)"""
    dispatcher_dict = docopt(__doc__.format(__file__), options_first=True)
    command, raw_args = dispatcher_dict["<command>"], dispatcher_dict["<args>"]
    if (command is not None) and (command[0] != "_"):
        submodule = getattr(module, command, None)
        submodule_entrypoint = getattr(submodule, "main", None)
        if submodule_entrypoint:
            __command_doc__ = submodule.__doc__.lstrip().format(
                __file__, " "*len(__file__)
            )
            docopt_dict = docopt(__command_doc__, argv=[command, *raw_args])
            kwargs = postprocess_docopt(submodule, docopt_dict, __command_doc__)
            return submodule_entrypoint(**kwargs, file=stdout)
    print(__doc__.format(__file__).lstrip(), file=stderr)
    return 1


if __name__ == "__main__":
    returncode = main(edgecaselib)
    exit(returncode)




#EXCLUDE_RULES = {
#    ("-x", "--index"): {"levenshtein", "repeatfinder", "kmerscanner"},
#}


#create_subparser(
#    subparsers, "tailchopper", help="get overhanging heads/tails of reads",
#    usage="{} tailchopper [options] bam > sam".format(__file__),
#    rules={
#        ("bam",):           dict(help="name of input BAM/SAM file"),
#        ("-t", "--target"): dict(help="an ECX flag (cut relative to reference) or 'cigar'", choices=CHOPPER_FLAGS, default="tract_anchor"),
#    }
#)
#
#create_subparser(
#    subparsers, "repeatfinder", help="discover enriched repeats in candidate sequences",
#    usage="{} repeatfinder [options] sequencefile > tsv".format(__file__),
#    rules={
#        ("sequencefile",):               dict(help="name of input SAM/BAM/FASTA/FASTQ file"),
#        ("--fmt",):                      dict(help="format of input file(s)", choices={"sam", "fastx"}, default="sam"),
#        ("-m", "--min-k"):               dict(help="smallest target repeat length", metavar="m", type=int, default=4),
#        ("-M", "--max-k"):               dict(help="largest target repeat length", metavar="M", type=int, default=16),
#        ("-n", "--max-motifs"):          dict(help="maximum number of motifs to report", metavar="N", type=int),
#        ("-P", "--max-p-adjusted"):      dict(help="cutoff adjusted p-value", metavar="P", type=float, default=.05),
#        ("--no-context",):               dict(help="allow single interspersed instances of kmers", action="store_true"),
#        ("--jellyfish",):                dict(help="jellyfish binary (unless in $PATH)"),
#        ("-s", "--jellyfish-hash-size"): dict(help="jellyfish initial hash size", metavar="S", default="2G"),
#        ("-j", "--jobs"):                dict(help="number of jellyfish jobs (parallel threads)", metavar="J", type=int, default=1),
#    }
#)
#
#create_subparser(
#    subparsers, "kmerscanner", help="perform scan of known kmers/motifs",
#    usage="{} kmerscanner [options] bam > dat".format(__file__),
#    rules={
#        ("bam",):                dict(help="name of input SAM/BAM file"),
#        ("-j", "--jobs"):        dict(help="number of jobs to run in parallel", metavar="J", type=int, default=1),
#        ("--motif-file",):       dict(help="file with repeated motif sequences (output of `repeatfinder`)", metavar="M", required=True, default="no default, required"),
#        ("--head-test",):        dict(help="length of head to use for density filter (if specified)", metavar="H", type=int),
#        ("--tail-test",):        dict(help="length of tail to use for density filter (if specified)", metavar="T", type=int),
#        ("-c", "--cutoff"):      dict(help="use hard cutoff for density", metavar="C", type=float),
#        ("-w", "--window-size"): dict(help="size of the rolling window", metavar="W", type=int, default=100),
#        ("-n", "--num-reads"):   dict(help="expected number of reads in input (for progress display)", metavar="N", type=int),
#    }
#)
#
#create_subparser(
#    subparsers, "densityplot", help="visualize densities of candidate reads",
#    usage="{} densityplot [options] dat > pdf".format(__file__),
#    rules={
#        ("dat",):             dict(help="input density file"),
#        ("-z", "--gzipped") : dict(help="input is gzipped (must specify if any of -qfF present)", action="store_true"),
#        ("-b", "--bin-size"): dict(help="size of each bin in bp for visualization speedup", metavar="B", type=int, default=100),
#        ("-e", "--exploded"): dict(help="plot each read separately", action="store_true"),
#        ("--zoomed-in",):     dict(help="plot taller traces, cut off pre-anchor regions", action="store_true"),
#        ("--palette",):       dict(help="custom palette for plotting motifs", metavar="P"),
#        ("--title",):         dict(help="figure title (defaults to input filename)", metavar="T"),
#    }
#)
