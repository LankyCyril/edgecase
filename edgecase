#!/usr/bin/env python3
from argparse import ArgumentParser, ArgumentDefaultsHelpFormatter
from edgecaselib import tailpuller, tailchopper, kmerscanner, densityplot
from edgecaselib import assembler


def WideHelpFormatter(prog):
    """Supply formatter class to ArgumentParser with wider fields than default"""
    return ArgumentDefaultsHelpFormatter(prog, max_help_position=30, width=150)


def create_subparser(subparsers, name, help, usage, rules):
    """Wrapper for easily creating subparsers and pushing into parent parser"""
    _subparser = subparsers.add_parser(
        name, help=help, usage=usage, formatter_class=WideHelpFormatter
    )
    for rule_args, rule_kwargs in rules.items():
        _subparser.add_argument(*rule_args, **rule_kwargs)


parser = ArgumentParser(prog=__file__, formatter_class=WideHelpFormatter)
parser.add_argument(
    "-j", "--jobs", help="number of jobs to run in parallel",
    default=1, type=int, metavar="J"
)
subparsers = parser.add_subparsers(dest="subparser")

create_subparser(
    subparsers, "tailpuller", help="select overhanging reads",
    usage="{} tailpuller [options] bam > sam".format(__file__),
    rules={
        ("bam",): {
            "help": "name of input BAM/SAM file"
        },
        ("-x", "--index"): {
            "help": "location of the reference .ecx index",
            "required": True, "metavar": "X", "default": "no default, required"
        },
        ("-F", "--flag-filter"): {
            "help": "process only sam entries with none of these flags present",
            "default": "0", "type": str, "metavar": "F"
        },
        ("-m", "--max-read-length"): {
            "help": "max read length to consider when selecting lookup regions",
            "default": None, "type": int, "metavar": "M"
        }
    }
)

create_subparser(
    subparsers, "tailchopper", help="get clipped heads/tails of reads",
    usage="{} tailchopper [options] bams > fasta".format(__file__),
    rules={
        ("bams",): {
            "help": "name(s) of input BAM/SAM file(s)", "nargs": "+"
        },
        ("-p", "--prime"): {
            "help": "which 'prime' end to output",
            "default": 5, "type": int, "choices": [5, 3]
        }
    }
)

create_subparser(
    subparsers, "kmerscanner", help="perform kmer scan",
    usage="{} [-j J] kmerscanner [options] bams > dat".format(__file__),
    rules={
        ("readfiles",): {
            "help": "name(s) of input sam/fasta/fastq file(s)", "nargs": "+"
        },
        ("--fmt",): {
            "help": "format of input file(s)", "default": "sam",
            "choices": {"sam", "fastx"}
        },
        ("--motifs",): {
            "help": "target motif sequences", "default": "TTAGGG", "metavar": "M"
        },
        ("--head-test",): {
            "help": "length of head to use for density filter (if specified)",
            "default": None, "type": int, "metavar": "H"
        },
        ("--tail-test",): {
            "help": "length of tail to use for density filter (if specified)",
            "default": None, "type": int, "metavar": "T"
        },
        ("-c", "--cutoff"): {
            "help": "use hard cutoff for density",
            "default": None, "type": float, "metavar": "C"
        },
        ("-w", "--window-size"): {
            "help": "size of the rolling window",
            "default": 120, "type": int, "metavar": "W"
        },
        ("-n", "--num-reads"): {
            "help": "expected number of reads in input (for progress display)",
            "default": None, "type": int, "metavar": "N"
        }
    }
)

create_subparser(
    subparsers, "densityplot", help="visualize densities of candidate reads",
    usage="{} densityplot [options] dat > pdf".format(__file__),
    rules={
        ("dat",): {
            "help": "input density file"
        },
        ("-z", "--gzipped") : {
            "help": "input is gzipped (must specify if any of -qfF present)",
            "action": "store_true"
        },
        ("-x", "--index"): {
            "help": "location of the reference .ecx index",
            "required": True, "metavar": "X", "default": "no default, required"
        },
        ("-f", "--flags"): {
            "help": "process only entries with all these sam flags present",
            "default": "0", "type": str, "metavar": "f"
        },
        ("-F", "--flag-filter"): {
            "help": "process only entries with none of these sam flags present",
            "default": "0", "type": str, "metavar": "F"
        },
        ("-q", "--min-quality"): {
            "help": "process only entries with MAPQ >= Q",
            "default": 0, "type": int, "metavar": "Q"
        },
        ("-b", "--bin-size"): {
            "help": "size of each bin in bp for visualization speedup",
            "default": 100, "type": int, "metavar": "B"
        },
        ("--title",): {
            "help": "figure title (defaults to input filename)", "metavar": "T"
        },
        ("--no-align",): {
            "help": "plot unaligned", "action": "store_true"
        }
    }
)

create_subparser(
    subparsers, "assembler", help="assemble haplotypes at ends of chromosomes",
    usage="{} assembler [options] bam".format(__file__),
    rules={
        ("bam",): {
            "help": "input tailpuller file"
        },
        ("-r", "--reference"): {
            "help": "reference FASTA (with .fai and .ecx indices)",
            "required": True, "metavar": "R", "default": "no default, required"
        },
        ("-c", "--chromosomes"): {
            "help": "target chromosome(s) (if not specified, target all)",
            "default": None, "metavar": "C"
        },
        ("-k", "--kmer-size"): {
            "help": "kmer size used for assembly",
            "default": 6, "type": int, "metavar": "K"
        },
        ("-o", "--output-prefix"): {
            "help": "output prefix",
            "required": True, "metavar": "O", "default": "no default, required"
        }
    }
)

kwargs = dict(parser.parse_args()._get_kwargs())
if kwargs["subparser"] in subparsers.choices:
    globals()[kwargs["subparser"]].main(**kwargs)
else:
    exit(parser.print_help() or 1)
