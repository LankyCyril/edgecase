from pysam import FastxFile, AlignmentFile
from matplotlib.pyplot import switch_backend, subplots
from collections import OrderedDict
from venn import venn, generate_petal_labels
from matplotlib_venn import venn3 as euler3
from tempfile import NamedTemporaryFile
from os import remove
from gzip import open as gzopen
from re import search, split
switch_backend("Agg")

rule combined_hmmer_kmerscan:
    input:
        v1="data/hmmer/twins-ont-2018/{subject}-{timepoint}.fq",
        v2="data/hmmer/twins-ont-2019/{subject}-{timepoint}.fq"
    output:
        densities="data/kmers/combined/{subject}-{timepoint}-{kmer}.txt"
    params:
        edge_size=600,
        window_size=120,
        cutoff=.2 # use hard cutoff if int/float, GMM if False
    threads: 24
    run:
        if wildcards.kmer == "TTAGGG":
            test_mode = "--tail-test"
        elif wildcards.kmer == "CCCTAA":
            test_mode = "--head-test"
        else:
            raise ValueError("Unsupported kmer: {}".format(wildcards.kmer))
        if isinstance(params.cutoff, (int, float)):
            cutoff_mode = "--cutoff {}".format(params.cutoff)
        else:
            cutoff_mode = ""
        shell("""
            python kmer-scan.py -j {threads} \
                --kmer {wildcards.kmer} \
                --window-size {params.window_size} \
                {test_mode} {params.edge_size} \
                {cutoff_mode} \
                {input.v1} {input.v2} \
                > {output.densities}
        """)

def names_from_txt(filename):
    with open(filename) as txt:
        return [line.strip().split()[0] for line in txt]

def names_from_fq(filename):
    with FastxFile(filename) as fastx:
        return [read.name for read in fastx]

def get_read_sets(input):
    if hasattr(input, "kmerscan"):
        kmerscan = set(names_from_txt(input.kmerscan))
    else:
        kmerscan = (
            set(names_from_txt(input.kmerscan_TTAGGG)) |
            set(names_from_txt(input.kmerscan_CCCTAA))
        )
    if hasattr(input, "basecomp"):
        basecomp = set(names_from_fq(input.basecomp))
    else:
        basecomp = kmerscan
    return OrderedDict([
        ("kmerscan", kmerscan),
        ("basecomp", basecomp),
        ("hmmer", (
            set(names_from_fq(input.hmmer_v1)) |
            set(names_from_fq(input.hmmer_v2))
        ))
    ])

def euler_labels(read_sets):
    venn_labels = generate_petal_labels(read_sets.values())
    return [
        int(venn_labels[logic])
        for logic in ("100", "010", "110", "001", "101", "011", "111")
    ]

rule threeway_venn:
    input:
        kmerscan_TTAGGG="data/kmers/combined/{subject}-{timepoint}-TTAGGG.txt",
        kmerscan_CCCTAA="data/kmers/combined/{subject}-{timepoint}-CCCTAA.txt",
        basecomp="data/basecomp/{subject}-{timepoint}.fq",
        hmmer_v1="data/hmmer/twins-ont-2018/{subject}-{timepoint}.fq",
        hmmer_v2="data/hmmer/twins-ont-2019/{subject}-{timepoint}.fq"
    output:
        png="data/plots/{subject}-{timepoint}/{diagram_type}-diagram.png"
    params:
        figsize=(8, 8)
    run:
        read_sets = get_read_sets(input)
        figure, ax = subplots(figsize=params.figsize)
        if wildcards.diagram_type == "venn":
            venn(read_sets, ax=ax)
        elif wildcards.diagram_type == "euler":
            euler3(
                subsets=euler_labels(read_sets),
                set_labels=read_sets.keys(),
                ax=ax
            )
        else:
            raise ValueError("Unsupported diagram type")
        ax.set(title="{} {}".format(wildcards.subject, wildcards.timepoint))
        figure.savefig(output.png)

rule all_eulers:
    input:
        pngs=expand(
            "data/plots/{subject}-{timepoint}/euler-diagram.png",
            subject=["TW", "HR"],
            timepoint=["pre", "flight", "post"]
        )

def plot_metrics(input, output, wildcards, title, names):
    with open(input.kmerscan) as kmerscan:
        with NamedTemporaryFile(delete=False, mode="wt") as tmp_txt:
            for line in map(str.strip, kmerscan):
                if line.split()[0] in names:
                    print(line, file=tmp_txt)
    if wildcards.kmer == "TTAGGG":
        align = "right"
    elif wildcards.kmer == "CCCTAA":
        align = "left"
    else:
        raise ValueError("Unsupported kmer: {}".format(wildcards.kmer))
    shell("""
        python plot-metric.py -a {align} --hide-names --title '{title}' \
            {tmp_txt.name} > {output.png}
    """)
    os.remove(tmp_txt.name)

rule TP_metrics_plot:
    input:
        kmerscan="data/kmers/combined/{subject}-{timepoint}-{kmer}.txt",
        basecomp="data/basecomp/{subject}-{timepoint}.fq",
        hmmer_v1="data/hmmer/twins-ont-2018/{subject}-{timepoint}.fq",
        hmmer_v2="data/hmmer/twins-ont-2019/{subject}-{timepoint}.fq"
    output:
        png="data/plots/{subject}-{timepoint}/tp-{kmer}.png"
    run:
        read_sets = get_read_sets(input)
        tp_names = set.intersection(*read_sets.values())
        title = "{}-{}: {} true positives".format(
            wildcards.subject, wildcards.timepoint, wildcards.kmer
        )
        plot_metrics(input, output, wildcards, title, tp_names)

rule kmerscan_FP_metrics_plot:
    input:
        kmerscan="data/kmers/combined/{subject}-{timepoint}-{kmer}.txt",
        basecomp="data/basecomp/{subject}-{timepoint}.fq",
        hmmer_v1="data/hmmer/twins-ont-2018/{subject}-{timepoint}.fq",
        hmmer_v2="data/hmmer/twins-ont-2019/{subject}-{timepoint}.fq"
    output:
        png="data/plots/{subject}-{timepoint}/kmerscan-fp-{kmer}.png"
    run:
        read_sets = get_read_sets(input)
        fp_names = read_sets["kmerscan"] - read_sets["basecomp"]
        title = "{}-{}: {} kmer-scan false? positives".format(
            wildcards.subject, wildcards.timepoint, wildcards.kmer
        )
        plot_metrics(input, output, wildcards, title, fp_names)

rule combined_basecomp_kmerscan:
    input:
        fq="data/basecomp/{subject}-{timepoint}.fq"
    output:
        densities="data/kmers/combined/basecomp/{subject}-{timepoint}-{kmer}.txt"
    run:
        shell("""
            python kmer-scan.py -j {threads} \
                --kmer {wildcards.kmer} \
                {input.fq} \
                > {output.densities}
        """)

rule basecomp_FP_metrics_plot:
    input:
        kmerscan="data/kmers/combined/basecomp/{subject}-{timepoint}-{kmer}.txt",
        hmmer_v1="data/hmmer/twins-ont-2018/{subject}-{timepoint}.fq",
        hmmer_v2="data/hmmer/twins-ont-2019/{subject}-{timepoint}.fq"
    output:
        png="data/plots/{subject}-{timepoint}/basecomp-unique-{kmer}.png"
    run:
        read_sets = get_read_sets(input)
        fp_names = read_sets["kmerscan"] - read_sets["hmmer"]
        title = "{}-{}: {} basecomp false? positives".format(
            wildcards.subject, wildcards.timepoint, wildcards.kmer
        )
        plot_metrics(input, output, wildcards, title, fp_names)

rule all_metrics:
    input:
        pngs=expand(
            "data/plots/{subject}-{timepoint}/{kind}-{kmer}.png",
            subject=["TW", "HR"],
            timepoint=["pre", "flight", "post"],
            kind=["tp", "kmerscan-fp", "basecomp-unique"],
            kmer=["TTAGGG", "CCCTAA"]
        )

rule hmmfail_fa:
    input:
        full="data/reads/{batch}/{subject}-{timepoint}.fq.gz",
        hmmer="data/hmmer/{batch}/{subject}-{timepoint}.fq"
    output:
        fail="data/hmmer/{batch}/fail/{subject}-{timepoint}.fa.gz"
    run:
        with FastxFile(input.hmmer) as hmmer:
            hmmer_passed = {
                read.name for read in hmmer
            }
        with FastxFile(input.full) as full:
            with gzopen(output.fail, mode="wt", compresslevel=1) as fail:
                for read in full:
                    if read.name not in hmmer_passed:
                        print(">" + read.name, file=fail)
                        print(read.sequence, file=fail)

rule all_hmmfail:
    input:
        fqs=expand(
            "data/hmmer/{batch}/fail/{subject}-{timepoint}.fa.gz",
            batch=["twins-ont-2018", "twins-ont-2019"],
            subject=["TW", "HR"],
            timepoint=["pre", "flight", "post"]
        )

def is_good_entry(entry, reverse=False):
    if (not entry.is_unmapped) and (entry.is_reverse == reverse):
        if (not entry.is_secondary) and (not entry.is_supplementary):
            return True
    return False

rule bam_to_fiveprimeclip:
    input:
        bam="data/alignments/hs37d5/{subject}-{timepoint}.bam",
        bai="data/alignments/hs37d5/{subject}-{timepoint}.bam.bai"
    output:
        tsv="data/alignments/hs37d5/{subject}-{timepoint}-5primeclip.tsv"
    run:
        with AlignmentFile(input.bam) as bam, open(output.tsv, "wt") as tsv:
            print(
                "QNAME", "FLAG", "RNAME", "POS", "MAPQ", "CLIP",
                sep="\t", file=tsv
            )
            for entry in bam:
                if is_good_entry(entry, reverse=True):
                    leftclip_match = search(r'^(\d+[SH])+', entry.cigarstring)
                    if leftclip_match:
                        leftclip_string = leftclip_match.group()
                        leftclip = sum(
                            int(field)
                            for field in split(r'[HS]', leftclip_string)
                            if field.isdigit()
                        )
                        fields = [
                            entry.query_name, entry.flag, entry.reference_name,
                            entry.pos, entry.mapq, leftclip
                        ]
                        print(*fields, sep="\t", file=tsv)
